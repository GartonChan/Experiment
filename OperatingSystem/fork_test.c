#include <stdio.h>
#include <sys/types.h>  // 提供类型pid_t的定义, 在PC机上与int型相同
#include <unistd.h>  // 提供系统调用的定义

/* 
    一个进程，包括代码、数据和分配给进程的资源。
    fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程，
    也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。

    一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。
    然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。
    相当于克隆了一个自己。
*/

// pid为每个进程提供了类似身份证一样能唯一标识的值,可以用作访问内核中进程的各种属性的索引

int main(int argc, char const *argv[])
{
    pid_t pid;  // 此时仅有一个进程
    int count = 0;  //  --->>  为了体现是两个进程在执行而引入一个计数器.两个进程各自表明父子关系和输出pid后,count自增后应该都输出1
    printf("pid_t类型新创建一个进程pid, pid=%d\n", pid);
    printf("PID before fork(), getpid()获取新创建进程的PID:%d\n\n", (int)getpid());
    pid = fork();  // 创建新的进程  // fork()函数拷贝当前进程创建子进程
    // 此时已有两个进程在同时运行
    printf("pid=fork();的下一条语句\n\n");
    if (pid<0)  // 表明创建子进程失败
        printf("error in fork!");
    else if (pid == 0){  // 为0创建子进程成功
        printf("子进程创建成功, 因此子进程的pid=%d\n", pid);
        printf("I am the child process, my process ID is %d\n", getpid());
        count++;
    }
    else{  // 这里原先进程的pid值被赋予了新创建的子进程的PID
        printf("fork()的返回值是新创建的子进程的PID, 此处赋给了pid(父进程)\n因此父进程的pid=%d\n", pid);
        printf("I am the parent process, my process ID is %d\n", getpid());
        count++;
    }
    printf("count = %d\n", count);
    return 0;
}  // 多次试验,在本机(Ubuntu18.04LTS下)执行次序不固定,是因为父,子进程的执行没有相互等待
   // 可以通过调用sleep(),wait()等函数来控制执行.


        /*   --- 笔记 ---  */
/*
    当一个进程新创建了子进程,执行流程可能有: 
        1.父,子进程序并发执行.  
        2.父进程一直等待,待它的部分/所有子进程终止(使用wait())
    新进程还有两种地址空间的可能性:
        1.子进程是父进程的副本(它具有与父进程相同的程序和数据).
        2.子进程加载了一个新程序到内存中运行.
    
    进程终止:
        由于各种原因,父进程可以终止其子进程的执行:
            1.子进程已超出已经分配给它的某些资源的使用范围(为了确定, 父进程必须有一个机制来检查子进程状态)
            2.分配给子进程的任务已经不需要再运行(完成)
            3.父进程正在退出,如果父进程终止,OS不允许子进程继续运行
        两种进程:
            (1)父进程终止,而子进程未终止 
                -> 孤儿进程, 处理方法:移交给init进程管理
            (2)父进程未终止,子进程终止,但父进程不知道 
                -> 僵尸进程, 处理方法:kill父进程,让其变孤儿
        
        当一个进程执行完最后一条语句,并要求操作系统使用exit()系统调用删除它时,它就终止了
        此时, 进程可能返回一个状态值(通常是整数)给它的父进程(通过wait()系统调用)
        进程的所有资源(包括缓存区)都被操作系统回收.

        有些系统不允许在父进程终止时子进程仍存在,这样一个进程终止,它的所有子进程也必须终止 
            -> 级联终止   通常由操作系统启动

*/    

        /*  --- 补充 ---  */
/*
    fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：
        1）在父进程中，fork返回新创建子进程的进程ID；
        2）在子进程中，fork返回0；
        3）如果出现错误，fork返回一个负值
*/